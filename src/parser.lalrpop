use std::str::FromStr;
use crate::lexer::{Token, LexicalError};
use crate::ast::{Ast, Span};

grammar(file_id: usize);

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "(" => Token::LPren,
        ")" => Token::RPren,
        "true" => Token::True,
        "false" => Token::False,
        "string" => Token::StrLit(<String>),
        "number" => Token::NumLit(<String>),
        "symbol" => Token::Symbol(<String>),
        "keyword" => Token::Keyword(<String>),
        "comment" => Token::Comment,
    }
}


pub Ast: Ast = {
    <l:@L> "(" <elems:(<Ast>)+> ")" <r:@R> => Ast::List(Span(l, r, file_id), elems),
    <x:Keyword> => x,
    <x:Symbol> => x,
    <l:@L> <x:Value> <r:@R> => Ast::Value(Span(l, r, file_id), x),
    <l:@L> "comment" <r:@R> => Ast::Comment(Span(l, r, file_id)),
};

Keyword: Ast = <l:@L> <x:"keyword"> <r:@R> => Ast::Keyword(Span(l, r, file_id), x.to_string());
Symbol: Ast = <l:@L> <x:"symbol"> <r:@R> => Ast::Symbol(Span(l, r, file_id), x.to_string());

Value: String = {
    <StrLit> => <>,
    <Num> => <>,
    <Bool> => <>,
};

StrLit: String = {
    <x:"string"> => {
      x[1..x.len() - 1].to_owned()
    },
};


Num: String = <"number"> => <>.to_string();
Bool: String = {
    "true" => "true".to_string(),
    "false" => "false".to_string(),
}


// vim:shiftwidth=4
